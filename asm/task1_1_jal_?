.data 0x0000
.text 0x0000

case1:
jal  load_data
# 在这个case1中，相关的是四号寄存器,其他的寄存器其实可以随便修改，不会影响任何后续结果
# 在这行之后，值已经存入了4号寄存器，而且4号的值，已经显示在了右边的16个灯上面,接下来是判断是否是回文数字,规定，如果是回文数字
# 我就亮起左边八个灯中的最右边的一个
add $5,$4,$20

loop_for_2:
sll $2,$2,1
andi $3,$5,1
or $2,$3,$2
sra $5,$5,1
bne $5,$0,loop_for_2

sw   $2,0xC60($28)    


#出来之后，4寄存器是原值，2寄存器是回文值
bne $4,$2,no
yes:
addi $1,$0,1
sw   $1,0xC62($28)
j end
no:
addi $1,$0,2
sw   $1,0xC62($28)
end:
j end




load_data:
addi  $20,$0,0
addi  $21,$0,1
lui   $1,0xFFFF   
ori   $28,$1,0xF000        
switled:


lw   $1,0xC70($28) 
lw   $3,0xC72($28) 
sw   $1,0xC60($28)     
sw   $3,0xC62($28)  

addi $2,$3,0
# 2已经取到了左边八位的数
# 下面是获取5寄存器内最终值的过程

sra  $2,$2,7
# 此时$2的值就取到了
addi $4,$1,0
# 这两行可要可不要
#sw   $1,0xC60($28)    
#sw   $3,0xC62($28)  

beq  $2,$21,during
j switled
during:
lw   $3,0xC72($28)  
beq $3,$20,back
j during
#ra寄存器
# 到此为止 方法体load_data写完了，其中
# 4寄存器用来保存每次获取的值
# 5寄存器用来获取测试场景的值


back:
jr $31





